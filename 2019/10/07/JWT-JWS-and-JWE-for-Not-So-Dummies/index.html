<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  <title>JWT, JWS and JWE for Not So Dummies | What Did I Just Read</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="shortcut icon" href="/">
  <link rel="stylesheet" href="/css/app.css">
  <!-- <link rel='stylesheet' href='http://fonts.useso.com/css?family=Source+Code+Pro'> -->
  
</head>
</html>
<body>
  <nav class="app-nav">
  
    
      <a href="/.">home</a>
    
  
    
      <a href="/archives">archive</a>
    
  
    
      <a href="/about">about</a>
    
  
</nav>

  <main class="post">
  <article>
  <h1 class="article-title">
    <a href="/2019/10/07/JWT-JWS-and-JWE-for-Not-So-Dummies/">JWT, JWS and JWE for Not So Dummies</a>
  </h1>

  <section class="article-meta">
    <p class="article-date">October 06 2019</p>
  </section>

  <section class="article-entry">
    <blockquote>
<p>Here’s the link to the original post written by Prabath Siriwardena:<br><a href="https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3" target="_blank" rel="noopener">https://medium.facilelogin.com/jwt-jws-and-jwe-for-not-so-dummies-b63310d201a3</a></p>
</blockquote>
<p>JSON Web Token (JWT) defines a container to transport data between interested parties. It became an IETF standard in May 2015 with the RFC 7519. There are multiple applications of JWT. The OpenID Connect is one of them. In OpenID Connect the <em>id_token</em> is represented as a JWT. Both in securing APIs and Microservices, the JWT is used as a way to propagate and verify end-user identity.</p>
<p><img src="https://miro.medium.com/max/1602/1*irEa-OWoGuI5oUIaF2YIxw.png" alt="img"></p>
<p>Propagating user identity from a mobile app to a secured API. The API has to verify and accept the JWT prior to any further processing.</p>
<p>A JWT can be used to:</p>
<ul>
<li>Propagate one’s identity between interested parties.</li>
<li>Propagate user entitlements between interested parties.</li>
<li>Transfer data securely between interested parties over a unsecured channel.</li>
<li>Assert one’s identity, given that the recipient of the JWT trusts the asserting party.</li>
</ul>
<a id="more"></a>

<p>Following is a sample JWT, which is returned back from the Google OpenID Connect provider. Here the Google, which is the identity provider, asserts the identity of an end-user and passes the JWT to a service provider (a web or native mobile application).</p>
<blockquote>
<p>eyJhbGciOiJSUzI1NiIsImtpZCI6Ijc4YjRjZjIzNjU2ZGMzOTUzNjRmMWI2YzAyOTA3NjkxZjJjZGZmZTEifQ.<strong>eyJpc3MiOiJhY2NvdW50cy5nb29nbGUuY29tIiwic3ViIjoiMTEwNTAyMjUxMTU4OTIwMTQ3NzMyIiwiYXpwIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiZW1haWwiOiJwcmFiYXRoQHdzbzIuY29tIiwiYXRfaGFzaCI6InpmODZ2TnVsc0xCOGdGYXFSd2R6WWciLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXVkIjoiODI1MjQ5ODM1NjU5LXRlOHFnbDcwMWtnb25ub21ucDRzcXY3ZXJodTEyMTFzLmFwcHMuZ29vZ2xldXNlcmNvbnRlbnQuY29tIiwiaGQiOiJ3c28yLmNvbSIsImlhdCI6MTQwMTkwODI3MSwiZXhwIjoxNDAxOTEyMTcxfQ</strong>.TVKv-pdyvk2gW8sGsCbsnkqsrS0T-H00xnY6ETkIfgIxfotvFn5IwKm3xyBMpy0FFe0Rb5Ht8AEJV6PdWyxz8rMgX2HROWqSo_RfEfUpBb4iOsq4W28KftW5H0IA44VmNZ6zU4YTqPSt4TPhyFC9fP2D_Hg7JQozpQRUfbWTJI</p>
</blockquote>
<p>This looks gibberish till you break it by periods (.) and base64url-decode each part. There are two periods in it, which break the whole string into three parts. Once you base64url-decode the fist part, it appears like below:</p>
<blockquote>
<p>{“alg”:”RS256”,”kid”:”78b4cf23656dc395364f1b6c02907691f2cdffe1”}</p>
</blockquote>
<h2 id="JOSE-Header"><a href="#JOSE-Header" class="headerlink" title="JOSE Header"></a>JOSE Header</h2><p>This first part(once parted by the periods) of the JWT is known as the JOSE header . JOSE stands for <em>Javascript Object Signing and Encryption</em> — and it’s the name of the IETF working group, which works on standardizing the representation of integrity-protected data using JSON data structures. The above JOSE header indicates that it’s a signed message. Google asserts the identity of the end-user by signing the JWT, which carries data related to the user’s identity.</p>
<p><img src="https://miro.medium.com/max/1800/1*wPdj47hp3Ig4heVcX0NEHA.png" alt="img"></p>
<p>Login to a service provider via Google OpenID Connect. In step-5 and step-7 user information is returned back to the service provider in a JWT, signed by Google.</p>
<p>A signed JWT is known as a JWS (JSON Web Signature). In fact a JWT does not exist itself — either it has to be a JWS or a JWE (JSON Web Encryption). Its like an abstract class — the JWS and JWE are the concrete implementations.</p>
<p><img src="https://miro.medium.com/max/818/1*rw1iGL8kdjSI3hNYIiSXNw.png" alt="img"></p>
<p>Going back to the JOSE header returned back from Google, both the <strong>alg</strong> and <strong>kid</strong> elements there, are not defined in the JWT specification, but in the JSON Web Signature (JWS) specification. The JWT specification only defines two elements (<strong>typ</strong> and <strong>cty</strong>) in the JOSE header and both the JWS and JWE specifications extend it to add more appropriate elements.</p>
<blockquote>
<p><strong>typ (type)</strong>: The <strong>typ</strong> element is used to define the media type of the complete JWT. A media type is an identifier, which defines the format of the content, transmitted on the Internet. There are two types of components that process a JWT: JWT implementations and JWT applications. Nimbus is a JWT implementation in Java. The Nimbus library knows how to build and parse a JWT. A JWT application can be anything, which uses JWTs internally. A JWT application uses a JWT implementation to build or parse a JWT. In this case, the <strong>typ</strong> element is just another element for the JWT implementation. It will not try to interpret the value of it, but the JWT application would. The <strong>typ</strong> element helps JWT applications to differentiate the content of the JWT when the values that are not JWTs could also be present in an application data structure along with a JWT object. This is an optional element and if present for a JWT, it is recommended to use <strong>JWT</strong> as the media type.</p>
<p><strong>cty (content type)</strong>: The <strong>cty</strong> element is used to define the structural information about the JWT. It is only recommended to use this element in the case of a nested JWT.</p>
</blockquote>
<p>The JWS specification is not bound to any specific algorithm. All applicable algorithms for signing are defined under the JSON Web Algorithms (JWA) specification, which is the RFC 7518. The section 3.1 of RFC 7518 defines all possible <strong>alg</strong> element values for a JWS token. The value of the <strong>kid</strong> element provides an indication or a hint about the key, which is used to sign the message. Looking at the <strong>kid</strong>, the recipient of the message should know where and how to lookup for the key and find it.</p>
<blockquote>
<p>In a JWT, the members of the JSON object represented by the JOSE header describe the cryptographic operations applied to the JWT and optionally, additional properties of the JWT. Depending upon whether the JWT is a JWS or JWE, the corresponding rules for the JOSE header values apply. Both under the JWS and JWE, the JOSE header is a must — or in other words there exists no JWT without a JOSE header.</p>
</blockquote>
<h2 id="Unsecured-JWT"><a href="#Unsecured-JWT" class="headerlink" title="Unsecured JWT"></a>Unsecured JWT</h2><p>A JWT can be either a JWS or a JWE object. Unsecured JWT is a JWS object where in the JOSE header the value of the <strong>alg</strong> element is set to <strong>none</strong>. In other words, an unsecured JWT is a JWS without a signature (sounds bit weird though :-)). When propagating user identity and entitlement information over an unsecured JWT, it is expected that the underlying transport will provide a guarantee on the integrity and the confidentiality of the token; use TLS.</p>
<h2 id="Claim-Set"><a href="#Claim-Set" class="headerlink" title="Claim Set"></a>Claim Set</h2><p>Focus back on the sample JWT returned back from Google. More precisely now we know its a JWS. Following shows the base64url-decoded claim set returned back from Google. The second part of the JWT (when parted by the period (.)) is known as the JWT claim set. White-spaces can be explicitly retained while building the JWT claim set — no canonicalization is required before base64url-encoding or decoding. <em>Canonicalization</em> is the process of converting different forms of a message into a single standard form. This is used mostly before signing XML messages.</p>
<p><img src="https://miro.medium.com/max/1120/1*o4A-GOhRYlqYwVET7Jzm8Q.png" alt="img"></p>
<p>The JWT claim set represents a JSON object whose members are the claims asserted by the JWT issuer. Each claim name within a JWT must be unique. If there are duplicate claim names, then the JWT parser could either return a parsing error or just return back the claims set with the very last duplicate claim. JWT specification does not explicitly define what claims are mandatory and what are optional. It’s up to the each application of JWT to define mandatory and optional claims. For example, the OpenID Connect specification defines the mandatory and optional claims. According to the OpenID Connect core specification, <strong>iss</strong>, <strong>sub</strong>, <strong>aud</strong>, <strong>exp</strong> and <strong>iat</strong> are treated as mandatory elements, while <strong>auth_time</strong>, <strong>nonce</strong>, <strong>acr</strong>, <strong>amr</strong> and <strong>azp</strong> are optional elements. In addition to the mandatory and optional claims, which are defined in the specification, the identity provider can include additional elements into the JWT claim set.</p>
<h2 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h2><p>Once again, focus back on the sample JWT returned back from Google. The third part of the JWT (when parted by the period (.)), is the signature, which is also base64url-encoded. The cryptographic elements related to the signature are defined in the JOSE header. In this particular example, Google uses RSASSA-PKCS1-V1_5 with the SHA-256 hashing algorithm, which is expressed by the value of the <strong>alg</strong> element in the JOSE header: <strong>RS256</strong>.</p>
<h2 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h2><p>A signed or an encrypted message can be serialized in two ways by following the JWS or JWE specification: the <em>JWS/JWE compact serialization</em> and the <em>JWS/JWE JSON serialization</em>. The Google OpenID Connect response discussed before uses the JWS compact serialization. In fact, the OpenID Connect specification mandates to use JWS compact serialization and JWE compact serialization whenever necessary.</p>
<p>Now we can further refine our definition of the JWT. So far we know that both the JWS and JWE tokens are instances of the JWT. But that is not 100% precise. We call a JWS or JWE, a JWT only if it follows the compact serialization. Any JWT must follow compact serialization. In other words a JWS or JWE token, which follows JSON serialization cannot be called as a JWT.</p>
<h2 id="JWS-Compact-Serialization"><a href="#JWS-Compact-Serialization" class="headerlink" title="JWS Compact Serialization"></a>JWS Compact Serialization</h2><p>JWS compact serialization represents a signed JWT as a compact URL-safe string. This compact string has three main elements separated by periods (.): <strong>the</strong> <strong>JOSE header</strong>, <strong>the JWS payload</strong> and <strong>the JWS signature</strong>. If you use compact serialization against a JSON payload (or any payload — even XML), then you can have only a single signature, which is computed over the complete <strong>JOSE header</strong> and <strong>JWS payload</strong>.</p>
<p><img src="https://miro.medium.com/max/720/1*sz6bIndG2bTBGcZ8ocmM5Q.png" alt="img"></p>
<p>The structure of a JWS token formed by JWS compact serialization.</p>
<h2 id="JWS-Compact-Serialization-—-Signing-Process"><a href="#JWS-Compact-Serialization-—-Signing-Process" class="headerlink" title="JWS Compact Serialization — Signing Process"></a>JWS Compact Serialization — Signing Process</h2><p>Following lists out the signing process of a JWS under the compact serialization.</p>
<ul>
<li>Build a JSON object including all the header elements, which express the cryptographic properties of the JWS token — this is known as the JOSE header. As discussed before, the token issuer should advertise in the JOSE header, the public key corresponding to the key used to sign the message. This can be expressed via any of these header elements: <strong>jku</strong>, <strong>jwk</strong>, <strong>kid</strong>, <strong>x5u</strong>, <strong>x5c</strong>, <strong>x5t</strong> and <strong>x5t#s256</strong>.</li>
<li>Compute the base64url-encoded value against the UTF-8 encoded JOSE header from the 1st step, to produce the 1st element of the JWS token.</li>
<li>Construct the payload or the content to be signed — this is known as the JWS payload. <strong>The payload is not necessarily JSON</strong> — it can be any content. Yes, you read it correctly, the payload of a JWS necessarily need not to be JSON - if you’d like it can be XML too.</li>
<li>Compute the base64url-encoded value of the JWS payload from the previous step to produce the 2nd element of the JWS token.</li>
<li>Build the message to compute the digital signature or the Mac. The message is constructed as ASCII(BASE64URL-ENCODE(UTF8(JOSE Header)) ‘.’ BASE64URL-ENCODE(JWS Payload)).</li>
<li>Compute the signature over the message constructed in the previous step, following the signature algorithm defined by the JOSE header element <strong>alg</strong>. The message is signed using the private key corresponding to the public key advertised in the JOSE header.</li>
<li>Compute the base64url encoded value of the JWS signature produced in the previous step, which is the 3rd element of the serialized JWS token.</li>
<li>Now we have all the elements to build the JWS token in the following manner. The line breaks are introduced only for clarity.</li>
</ul>
<blockquote>
<p>BASE64URL(UTF8(JWS Protected Header)) ‘.’</p>
<p>BASE64URL(JWS Payload) ‘.’</p>
<p>BASE64URL(JWS Signature)</p>
</blockquote>
<h2 id="JWS-JSON-Serialization"><a href="#JWS-JSON-Serialization" class="headerlink" title="JWS JSON Serialization"></a>JWS JSON Serialization</h2><p>In contrast to the JWS compact serialization, the JWS JSON serialization can produce multiple signatures over the same JWS payload along with multiple JOSE headers. The ultimate serialized form under JWS JSON serialization wraps the signed payload in a JSON object, with all the related metadata. This JSON object includes 2 top-level elements: <strong>payload</strong> and <strong>signatures</strong> <em>(which is a JSON array)</em>, and three sub elements under each entry of the <strong>signatures</strong> array: <strong>protected</strong>, <strong>header</strong> and <strong>signature</strong>.</p>
<p>Following is an example of a JWS token, which is serialized under JWS JSON serialization.</p>
<p><img src="https://miro.medium.com/max/960/1*9NzP9wbeU3ecOKoua5tkeQ.png" alt="img"></p>
<p>This is neither URL safe nor optimized for compactness. It carries two signatures over the same payload, and each signature and the metadata around it are stored as an element in the JSON array, represented by the <strong>signatures</strong> top-level element. Each signature uses a different key to sign, represented by the corresponding <strong>kid</strong> header element.</p>
<p>The <strong>payload</strong> top-level element of the JSON object includes the base64url-encoded value of the complete JWS payload. The JWS payload not necessarily needs to be a JSON payload, it can be of any content type. The <strong>payload</strong> is a required element in the serialized JWS token.</p>
<h2 id="The-JWS-Protected-Header"><a href="#The-JWS-Protected-Header" class="headerlink" title="The JWS Protected Header"></a>The JWS Protected Header</h2><p>The JWS protected header is a JSON object that includes the header elements that has to be integrity protected by the signing or MAC algorithm. There can be multiple JWS protected headers in a JWS, serialized under JSON serialization, where each one of them carries the header elements that has to be signed differently. The JSON serialization is useful in selectively signing JOSE header elements, while in contrast JWS compact serialization signs the complete JOSE header.</p>
<p>Each <strong>protected</strong> element in the serialized JSON form represents the base64url-encoded value of a JWS protected header. The <strong>protected</strong> element is defined under each entry of the <strong>signatures</strong> JSON array and includes the base64url-encoded JSON object of header elements, which should be signed. If you base64url-decode the value of the first <strong>protected</strong> element in the above code snippet, you will see <strong>{“alg”:”RS256”}</strong>. The <strong>protected</strong> element must be present, if there are any JWS protected headers. There can be one <strong>protected</strong> element for each entry of the signatures JSON array.</p>
<h2 id="JWS-Unprotect-Header"><a href="#JWS-Unprotect-Header" class="headerlink" title="JWS Unprotect Header"></a>JWS Unprotect Header</h2><p>The JWS unprotected header is a JSON object, which includes the header elements that are not integrity protected by the signing or MAC algorithm. Each <strong>header</strong> element in the serialized JSON form represents the base64url-encoded value of a JWS unprotected header. The <strong>header</strong> element is defined under each entry in the <strong>signatures</strong> JSON array and includes unprotected header elements corresponding to this signature, which are not signed. Combining both the protected headers and unprotected headers ultimately derives the JOSE header corresponding to this signature (the metadata related to the signature can be either protected or unprotected). In the above code snippet, the complete JOSE header corresponding to the first entry in the <strong>signatures</strong> JSON array would be <strong>{“alg”:”RS256”, “kid”:”2010–12–29”}</strong>, which aggregates both the protected and unprotected headers. The <strong>header</strong> element itself is represented as a JSON object and must be present if there are any unprotected header elements. There can be one header element for each entry of the <strong>signatures</strong> JSON array.</p>
<p>The <strong>signatures</strong> element of the JSON object includes an array of JSON objects, where each element includes a signature or MAC (over the JWS payload and JWS protected header) and the associated metadata. This is a required element. The <strong>signature</strong> element, which is inside each entry of the <strong>signatures</strong> array carries the base64url-encoded value of the signature computed over the protected header elements (represented by the protected element) and the JWS payload. Both the <strong>signatures</strong> and <strong>signature</strong> are required elements.</p>
<h2 id="JWS-JSON-Serialization-—-Signing-Process"><a href="#JWS-JSON-Serialization-—-Signing-Process" class="headerlink" title="JWS JSON Serialization — Signing Process"></a>JWS JSON Serialization — Signing Process</h2><p>Following lists out the signing process of a JWS under the JSON serialization.</p>
<ul>
<li>Construct the payload or the content to be signed — this is known as the JWS payload. <strong>The payload is not necessarily JSON</strong> — it can be any content. The <strong>payload</strong> element in the serialized JWS token carries the base64url-encoded value of this.</li>
<li>Decide how many signatures you would need against the payload and for each case which header elements must be signed and which are not.</li>
<li>Build a JSON object including all the header elements that are to be integrity protected or to be signed. In other words construct the JWS protected header for each signature. The base64url-encoded value of the UTF-8 encoded JWS protected header will produce the value of the corresponding <strong>protected</strong> element inside each entry of the <strong>signatures</strong> JSON array.</li>
<li>Build a JSON object including all the header elements that need not to be integrity protected or not to be signed. In other words construct the JWS unprotected header for each signature. This will produce the corresponding <strong>header</strong> element inside each entry of the <strong>signatures</strong> JSON array.</li>
<li>Both the JWS protected header and the JWS unprotected header express the cryptographic properties of the corresponding signature — this is known as the JOSE header. As discussed before the token issuer should advertise in the JOSE header, the public key corresponding the key used to sign the message. This can be expressed via any of these header elements: <strong>jku</strong>, <strong>jwk</strong>, <strong>kid</strong>, <strong>x5u</strong>, <strong>x5c</strong>, <strong>x5t</strong> and <strong>x5t#s256</strong>.</li>
<li>Build the message to compute the digital signature or the Mac against each entry in the <strong>signatures</strong> JSON array of the serialized JWS token. The message is constructed as ASCII(BASE64URL-ENCODE(UTF8(JWS Protected Header of the corresponding entry)) ‘.’ BASE64URL-ENCODE(JWS Payload)).</li>
<li>Compute the signature over the message constructed in the previous step, following the signature algorithm defined in the corresponding header element: <strong>alg</strong>. This element can be either inside the JWS protected header or the JWS unprotected header. The message is signed using the private key corresponding to the public key advertised in the header.</li>
<li>Compute the base64url encoded value of the JWS signature produced in the previous step, which will produce the value of the <strong>signature</strong> element inside the <strong>signatures</strong> JSON array of the serialized JWS token.</li>
<li>Once all the signatures are computed, the <strong>signatures</strong> JSON array can be constructed and will complete the JWS JSON serialization.</li>
</ul>
<h2 id="JWE-JSON-Web-Encryption"><a href="#JWE-JSON-Web-Encryption" class="headerlink" title="JWE (JSON Web Encryption)"></a>JWE (JSON Web Encryption)</h2><p>The JWE (JSON Web Encryption) specification standardizes the way to represent an encrypted content in a JSON-based data structure. It defines two serialized forms to represent the encrypted payload: the <strong>JWE compact serialization</strong> and <strong>JWE JSON serialization</strong>. Both of these two serialization techniques are discussed in detail, in the sections to follow. Like in JWS, <strong>the message to be encrypted using JWE standard needs not to be a JSON payload, it can be any content</strong>.</p>
<h2 id="JWE-Compact-Serialization"><a href="#JWE-Compact-Serialization" class="headerlink" title="JWE Compact Serialization"></a>JWE Compact Serialization</h2><p>With the JWE compact serialization, a JWE token is built with five key components, each separated by a period (.): <strong>JOSE header</strong>, <strong>JWE Encrypted Key</strong>, <strong>JWE initialization vector</strong>, <strong>JWE Additional Authentication Data (AAD)</strong>, <strong>JWE Ciphertext</strong> and <strong>JWE Authentication Tag</strong>.</p>
<p><img src="https://miro.medium.com/max/720/1*-qEUNh7EYxBbnnt0Xk997g.png" alt="img"></p>
<p>The structure of a JWE token formed by JWE compact serialization.</p>
<p>The JOSE header is the very first element of the JWE token produced under compact serialization. The structure of the JOSE header is the same, as we discussed under JWS other than couple of exceptions. The JWE specification introduces two new elements (<strong>enc</strong> and <strong>zip</strong>), which are included in the JOSE header of the JWE token, in addition to what’s defined by the JSON Web Signature (JWS) specification.</p>
<p>To understand <strong>JWE Encrypted Key</strong> section of the JWE, we first need to understand how a JSON payload gets encrypted. The <strong>enc</strong> element of the JOSE header defines the <strong>content encryption</strong> <strong>algorithm</strong> and it should be a symmetric <strong>Authenticated Encryption with Associated Data (AEAD)</strong> algorithm. The <strong>alg</strong> element of the JOSE header defines the encryption algorithm to encrypt the <strong>Content Encryption Key (CEK)</strong>. This algorithm can also be defined as the key wrapping algorithm, as it wraps the <strong>CEK</strong>.</p>
<blockquote>
<p><strong>Authenticated Encryption with Associated Data (AEAD)</strong> is a block cipher mode of operation which simultaneously provides confidentiality, integrity, and authenticity assurances on the data; decryption is combined in single step with integrity verification.</p>
</blockquote>
<p>Let’s look at the following JOSE header. For content encryption, it uses <strong>A256GCM</strong> algorithm; and for key wrapping, <strong>RSA-OAEP</strong>:</p>
<blockquote>
<p>{“alg”:”RSA-OAEP”,”enc”:”A256GCM”}</p>
</blockquote>
<p><strong>A256GCM</strong> is defined in the JWA specification. It uses the <strong>Advanced Encryption Standard (AES) in Galois/Counter Mode (GCM)</strong> algorithm with a 256-bit long key, and it’s a symmetric key algorithm used for <strong>AEAD</strong>. Symmetric keys are mostly used for content encryption and it is much faster than asymmetric-key encryption. At the same time, asymmetric-key encryption can’t be used to encrypt large messages.</p>
<p><strong>RSA-OAEP</strong> is too defined in the JWA specification. During the encryption process, the token issuer generates a random key, which is 256 bits in size and encrypts the message using that key following the <strong>AES GCM</strong> algorithm. Next, the key used to encrypt the message is encrypted using <strong>RSA-OAEP</strong>, which is an asymmetric encryption scheme. The <strong>RSA-OAEP</strong> encryption scheme uses <strong>RSA</strong> algorithm with the <strong>Optimal Asymmetric Encryption Padding (OAEP)</strong> method. Finally the encrypted symmetric key is placed in the <strong>JWE Encrypted Header</strong> section of the JWE.</p>
<p>Some encryption algorithms, which are used for content encryption require an initialization vector, during the encryption process. Initialization vector is a randomly generated number, which is used along with a secret key to encrypt data. This will add randomness to the encrypted data, which will prevent repetition even the same data gets encrypted using the same secret key again and again. To decrypt the message at the token recipient end, it has to know the initialization vector, hence it is included in the JWE token, under the <strong>JWE Initialization Vector</strong> element. If the content encryption algorithm does not require an initialization vector, then the value of this element should be kept empty.</p>
<p>The fourth element of the JWE token is the base64url-encoded value of the JWE ciphertext. The JWE ciphertext is computed by encrypting the plaintext JSON payload using the <strong>Content Encryption Key (CEK)</strong>, the <strong>JWE initialization vector</strong> and the <strong>Additional Authentication Data (AAD)</strong> value, with the encryption algorithm defined by the header element <strong>enc</strong>. The algorithm defined by the <strong>enc</strong> header element should be a symmetric <strong>Authenticated Encryption with Associated Data (AEAD)</strong> algorithm. The <strong>AEAD</strong> algorithm, which is used to encrypt the plaintext payload, also allows specifying <strong>Additional Authenticated Data (AAD)</strong>.</p>
<p>The base64url-encoded value of the <strong>JWE Authenticated Tag</strong> is the final element of the JWE token. As discussed before the value of the authentication tag is produced during the <strong>AEAD</strong> encryption process, along with the ciphertext. The authentication tag ensures the integrity of the ciphertext and the <strong>Additional Authenticated Data (AAD)</strong>.</p>
<h2 id="JWE-Compact-Serialization-—-Signing-Process"><a href="#JWE-Compact-Serialization-—-Signing-Process" class="headerlink" title="JWE Compact Serialization — Signing Process"></a>JWE Compact Serialization — Signing Process</h2><p>Following lists out the encryption process of a JWE under the compact serialization.</p>
<ul>
<li>Figure out the key management mode by the algorithm used to determine the <strong>Content Encryption Key (CEK)</strong> value. This algorithm is defined by the <strong>alg</strong> element in the JOSE header. There is only one <strong>alg</strong> element per JWE token<em>.</em></li>
<li>Compute the <strong>CEK</strong> and calculate the <strong>JWE Encrypted Key</strong> based on the key management mode, picked in the previous. The <strong>CEK</strong> is later used to encrypt the JSON payload. There is only one <strong>JWE Encrypted Key</strong> element in the JWE token.</li>
<li>Compute the base64url-encoded value of the <strong>JWE Encrypted Key</strong>, which is produced in the previous step. This is the 2nd element of the JWE token.</li>
<li>Generate a random value for the <strong>JWE Initialization Vector</strong>. Irrespective of the serialization technique, the JWE token will carry the value of the base64url-encoded value of the <strong>JWE Initialization Vector</strong>. This is the 3rd element of the JWT token.</li>
<li>If token compression is needed, the JSON payload in plaintext must be compressed following the compression algorithm defined under the <strong>zip</strong> header element.</li>
<li>Construct the JSON representation of the JOSE header and find the base64url-encoded value of the JOSE header with UTF8 encoding. This is the 1st element of the JWE token.</li>
<li>To encrypt the JSON payload, we need the <strong>CEK</strong> (which we already have), the <strong>JWE Initialization Vector</strong> (which we already have), and the <strong>Additional Authenticated Data (AAD)</strong>. Compute ASCII value of the encoded JOSE header from the previous step and use it as the <strong>AAD</strong>.</li>
<li>Encrypt the compressed JSON payload (from the previous step) using the <strong>CEK</strong>, the <strong>JWE Initialization Vector</strong> and the <strong>Additional Authenticated Data (AAD)</strong>, following the content encryption algorithm defined by the header <strong>enc</strong> header element.</li>
<li>The algorithm defined by the <strong>enc</strong> header element is a <strong>AEAD</strong> algorithm and after the encryption process, it produce the ciphertext and the <strong>Authentication Tag</strong>.</li>
<li>Compute the base64url-encoded value of the ciphertext, which is produced by the step one before the previous. This is the 4th element of the JWE token.</li>
<li>Compute the base64url-encoded value of the Authentication Tag, which is produced by the step one before the previous. This is the 5th element of the JWE token.</li>
<li>Now we have all the elements to build the JWE token in the following manner. The line breaks are introduced only for clarity.</li>
</ul>
<blockquote>
<p>BASE64URL-ENCODE(UTF8(JWE Protected Header)) ‘.’</p>
<p>BASE64URL-ENCODE(JWE Encrypted Key) ‘.’</p>
<p>BASE64URL-ENCODE(JWE Initialization Vector) ‘.’</p>
<p>BASE64URL-ENCODE(JWE Ciphertext) ‘.’</p>
<p>BASE64URL-ENCODE(JWE Authentication Tag)</p>
</blockquote>
<h2 id="JWE-JSON-Serialization"><a href="#JWE-JSON-Serialization" class="headerlink" title="JWE JSON Serialization"></a>JWE JSON Serialization</h2><p>Unlike the JWE compact serialization, the JWE JSON serialization can produce encrypted data targeting at multiple recipients over the same JSON payload. The ultimate serialized form under JWE JSON serialization represents an encrypted payload in a JSON object. This JSON object includes six top-level elements: <strong>protected</strong>, <strong>unprotected</strong>, <strong>recipients</strong>, <strong>iv</strong>, <strong>ciphertext</strong> and <strong>tag</strong>. Following is an example of a JWE token, which is serialized under JWE JSON serialization.</p>
<p><img src="https://miro.medium.com/max/1462/1*cVjXFOj-3AKti3OrxYMNAw.png" alt="img"></p>
<h2 id="The-JWE-Protected-Header"><a href="#The-JWE-Protected-Header" class="headerlink" title="The JWE Protected Header"></a>The JWE Protected Header</h2><p>The JWE protected header is a JSON object that includes the header elements that has to be integrity protected by the authenticated encryption operation (<strong>AEAD)</strong>. The elements inside the JWE protected header are applicable to all the recipients of the JWE token. The <strong>protected</strong> element in the serialized JSON form represents the base64url-encoded value of the JWE protected header. There can be only one <strong>protected</strong> element in a JWE token at the root level and any header elements that we discussed before under the JOSE header can also be used under the JWE protected header<em>.</em></p>
<h2 id="JWE-Shared-Unprotected-Header"><a href="#JWE-Shared-Unprotected-Header" class="headerlink" title="JWE Shared Unprotected Header"></a>JWE Shared Unprotected Header</h2><p>The JWE shared unprotected header is a JSON object that includes the header elements that are not integrity protected. The elements inside the JWE shared unprotected header are applicable to all the recipients of the JWE token. The <strong>unprotected</strong> element in the serialized JSON form represents the JWE shared unprotected header. There can be only one <strong>unprotected</strong> element in a JWE token, at the root level and any header element that we discussed before under the JOSE header can also be used under the JWE shared unprotected header<em>.</em></p>
<h2 id="JWE-Per-Recipient-Unprotected-Header"><a href="#JWE-Per-Recipient-Unprotected-Header" class="headerlink" title="JWE Per-Recipient Unprotected Header"></a><em>JWE Per-Recipient Unprotected Header</em></h2><p>The JWE per-recipient unprotected header is a JSON object that includes the header elements that are not integrity protected. The elements inside the JWE per-recipient unprotected header are applicable only to a particular recipient of the JWE token. In the JWE token, these header elements are grouped under the element, <strong>recipients</strong>. The <strong>recipients</strong> element represents an array of recipients of the JWE token. Each member consists of a <strong>header</strong> element and an <strong>encrypted_key</strong> element.</p>
<ul>
<li><strong>header</strong>: The <strong>header</strong> element, which is inside each entry of the <strong>recipients</strong> JSON array, represents the value of the corresponding JWE header elements that aren’t protected by authenticated encryption for each recipient.</li>
<li><strong>encrytedkey</strong>: The <strong>encrytedkey</strong> element represents the base64url-encoded value of the encrypted key. This is the key used to encrypt the message payload. The key can be encrypted in different ways for each recipient.</li>
</ul>
<p>Any header element that we discussed before under the JOSE header can also be used under the JWE per-recipient unprotected header<em>.</em></p>
<h2 id="JWE-Initialization-Vector"><a href="#JWE-Initialization-Vector" class="headerlink" title="JWE Initialization Vector"></a>JWE Initialization Vector</h2><p>This carries the same meaning as explained under JWE compact serialization, previously. The <strong>iv</strong> element in the JWE token represents the value of the initialization vector used for encryption.</p>
<h2 id="JWE-Ciphertext"><a href="#JWE-Ciphertext" class="headerlink" title="JWE Ciphertext"></a>JWE Ciphertext</h2><p>This carries the same meaning as explained under JWE compact serialization, previously. The <strong>ciphertext</strong> element in the JWE token carries the base64url-encoded value of the JWE ciphertext</p>
<h2 id="JWE-Authentication-Tag"><a href="#JWE-Authentication-Tag" class="headerlink" title="JWE Authentication Tag"></a>JWE Authentication Tag</h2><p>This carries the same meaning as explained under JWE compact serialization, previously. The <strong>tag</strong> element in the JWE token carries the base64url-encoded value of the JWE authenticated tag, which is an outcome of the encryption process using an <strong>AEAD</strong> algorithm.</p>
<h2 id="JWE-JSON-Serialization-—-Signing-Process"><a href="#JWE-JSON-Serialization-—-Signing-Process" class="headerlink" title="JWE JSON Serialization — Signing Process"></a>JWE JSON Serialization — Signing Process</h2><p>Following lists out the encryption process of a JWE under the JSON serialization.</p>
<ul>
<li>Figure out the key management mode by the algorithm used to determine the <strong>Content Encryption Key (CEK)</strong> value. This algorithm is defined by the <strong>alg</strong> element in the JOSE header. Under JWE JSON serialization, the JOSE header is built by the union of all the elements defined under the <strong>JWE Protected Header*</strong>,* <strong>JWE Shared Unprotected Header</strong> and <strong>Per-Recipient Unprotected Header*</strong>.* Once included in the <strong>Per-Recipient Unprotected Header</strong> the <strong>alg</strong> element can be defined per recipient.</li>
<li>Compute the <strong>CEK</strong> and calculate the <strong>JWE Encrypted Key</strong> based on the key management mode, picked in the previous step. The <strong>CEK</strong> is later used to encrypt the JSON payload.</li>
<li>Compute the base64url-encoded value of the <strong>JWE Encrypted Key</strong>, which is produced in the previous step. Once again this is computed per recipient and the resultant value is included in <em>the</em> <strong>Per-Recipient Unprotected Header</strong> element<em>,</em> <strong>encrytedkey</strong>.</li>
<li>Perform all three previous steps for each recipient of the JWE token. Each iteration will produce an element in the <strong>recipients</strong> JSON array of the JWE token.</li>
<li>Generate a random value for the <strong>JWE Initialization Vector</strong>. Irrespective of the serialization technique, the JWE token will carry the value of the base64url-encoded value of the <strong>JWE Initialization Vector</strong>.</li>
<li>If token compression is needed, the JSON payload in plaintext, must be compressed following the compression algorithm defined under the <strong>zip</strong> header element. The value of the <strong>zip</strong> header element can be defined either under the <strong>JWE Protected Header</strong> or <strong>JWE Shared Unprotected Header*</strong>.*</li>
<li>Construct the JSON representation of the <strong>JWE Protected Header*</strong>,* <strong>JWE Shared Unprotected Header</strong> and <strong>Per-Recipient Unprotected Headers*</strong>.*</li>
<li>Compute the base64url-encoded value of the <strong>JWE Protected Header</strong> with UTF8 encoding. This value is represented by the <strong>protected</strong> element in the serialized JWE token. The <strong>JWE Protected Header</strong> is optional and if present there can be only one header. If no JWE header is present, then the value of the <strong>protected</strong> element will be empty.</li>
<li>Generate a value for the <strong>Additional Authenticated Data (AAD)</strong> and compute the base64url-encoded value of it. This is an optional step and if it’s done, then the base64url-encoded <strong>AAD</strong> value will be used as an input element to encrypt the JSON payload, as explained in the next step.</li>
<li>To encrypt the JSON payload, we need the <strong>CEK</strong> (which we already have), the <strong>JWE Initialization Vector</strong> (which we already have), and the <strong>Additional Authenticated Data (AAD)</strong>. Compute ASCII value of the encoded <strong>JWE Protected Header</strong> (step one before the previous) and use it as the AAD. In case the previous step is done and then the value of AAD is computed as ASCII(encoded <em>JWE Protected Header</em> ‘.’ BASE64URL-ENCODE(AAD )).</li>
<li>Encrypt the compressed JSON payload (from step-6) using the <strong>CEK</strong>, the <strong>JWE Initialization Vector</strong> and the <strong>Additional Authenticated Data</strong> (AAD from the previous step), following the content encryption algorithm defined by the header <strong>enc</strong> header element.</li>
<li>The algorithm defined by the <strong>enc</strong> header element is a <strong>AEAD</strong> algorithm and after the encryption process, it produces the <strong>ciphertext</strong> and the <strong>Authentication Tag</strong>.</li>
<li>Compute the base64url-encoded value of the <strong>ciphertext</strong>, which is produced in the previous step.</li>
<li>Compute the base64url-encoded value of the <strong>Authentication Tag</strong>, which is produced in the step one before the previous.</li>
<li>Now we have all the elements to build the JWE token under JSON serialization.</li>
</ul>
<h2 id="JWT-Bindings"><a href="#JWT-Bindings" class="headerlink" title="JWT Bindings"></a>JWT Bindings</h2><p>A binding for a given token defines how to transport the token from one place to another. For example, SAML HTTP redirect binding defines how to transport a SAML request/response over HTTP redirect. The SAML SOAP binding defines how to transport a SAML request/response wrapped in a SOAP enveloper.</p>
<p>JWT does not have a standard binding. But in most of the cases, the JWT is transported over HTTP under the Authorization Bearer header (like in OAuth 2.0).</p>
<blockquote>
<p>Authorization: Bearer <jwt-token></jwt-token></p>
</blockquote>
<p>Everything we discussed so far assumed JWT is a bearer token. A bearer token means, who ever owns the token can use it without proving the ownership of the token. Its like cash. If you steal 100 bucks from someone, you do not need to prove how you got it when you want to spend it. If someone steals a bearer token he can just use it as the legitimate owner of it. Whenever you use a bearer token — or transport it from one place to another, it has to be done over a secured medium; user TLS.</p>
<h2 id="JWT-with-Proof-of-Possession"><a href="#JWT-with-Proof-of-Possession" class="headerlink" title="JWT with Proof of Possession"></a>JWT with Proof of Possession</h2><p>The RFC 7800 describes how a JWT can declare that the presenter of the JWT possesses a particular proof-of-possession (PoP) key and how the recipient can cryptographically confirm proof of possession of the key by the presenter. Proof of possession of a key is also sometimes described as the presenter being a holder-of-key. This is analogous to a credit card protected with the owner’s signature. Even if someone steals a credit card he cannot use it without proving the ownership. The ownership is proved by the signature. The JWTs issued under holder-of-key confirmation is out-0f-the-scope of this post and possibly we can discuss this in detail in a later post.</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>JWT is used to transport user identity/entitlements between interested parties in a secured manner.</li>
<li>JWS and JWE are instances of the JWT — when used compact serialization.</li>
<li>JWS and JWE can be serialized using either the compact serialization or JSON serialization.</li>
<li>JWT does not define a specific binding, but in practice JWT tokens are transported over HTTPS under the Authorization Bearer header, just as in OAuth 2.0.</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul>
<li>JWT : <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7519</a></li>
<li>JWS: <a href="https://tools.ietf.org/html/rfc7516" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7516</a></li>
<li>JWS: <a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7515</a></li>
<li>Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs) : <a href="https://tools.ietf.org/html/rfc7800" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7800</a></li>
</ul>

  </section>
</article>


  
</main>

</body>
</html>
